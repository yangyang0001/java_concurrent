------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------- 第1章 并发编程线程基础 ----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------
进程: 是系统进行资源分配和调度的 单位正交基!
线程: 是CPU资源分配和调度的 单位正交基!

实现线程的三种方法:
    1、继承Thread
    2、实现Runnable
    3、实现Callable 进而实现 FutrueTask 来实现自己的线程

线程通知和等待 wait(), notify(), notifyAll()
    虚假唤醒:
    一个线程从 挂起状态 变成 可运行状态, 这个过程称为唤醒;  线程A可能就该轮到他执行了, 并没有经过 其他线程B 的 notify(), notifyAll() 方法 进行唤醒, 这种就是典型的 虚假唤醒!

    防止虚假唤醒的方式:
    锁住的执行代码块之内使用, 一直判定的 满足条件才 wait()

    使用规范如下:
    synchronized(obj) {
        while(不满足获取 obj 监视器的条件) {
            obj.wait();
        }
        ...
        obj.notify();
    }

    或

    synchronized(obj) {
        while(不满足获取 obj 监视器的条件) {
            obj.wait();
        }
        ...
        obj.notifyAll();
    }

    源码解析:
    /**
     * TODO 使当前线程进入等待状态
     * 使当前线程等待，直到另一个线程为此对象调用 {@link java.lang.Object#notify()} 方法或 {@link java.lang.Object#notifyAll()} 方法。
     * Causes the current thread to wait until another thread invokes the {@link java.lang.Object#notify()} method or the {@link java.lang.Object#notifyAll()} method for this object.
     *
     * 换句话说，这个方法的行为就像它只是执行调用 {@code wait(0)} 一样。
     * In other words, this method behaves exactly as if it simply performs the call {@code wait(0)}.
     * <p>
     * 当前线程必须拥有此对象的监视器。
     * The current thread must own this object's monitor.
     *
     * 线程释放此监视器的所有权并等待，直到另一个线程通知在此对象监视器上等待的线程通过调用 {@code notify} 方法或 {@code notifyAll} 方法唤醒。
     * The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object's monitor to wake up either through a call to the {@code notify} method or the {@code notifyAll} method.
     *
     * 然后线程等待直到它可以重新获得监视器的所有权并恢复执行。
     * The thread then waits until it can re-obtain ownership of the monitor and resumes execution.
     * <p>
     * 与单参数版本一样，中断和虚假唤醒是可能的，并且应始终在循环中使用此方法：
     * As in the one argument version, interrupts and spurious wakeups are possible, and this method should always be used in a loop:
     * <pre>
     *     synchronized (obj) {
     *         while (condition does not hold)  // 条件不成立
     *             obj.wait();
     *         ... // Perform action appropriate to condition   执行适合条件的动作
     *     }
     * </pre>
     * 此方法只能由作为此对象监视器所有者的线程调用。
     * This method should only be called by a thread that is the owner of this object's monitor.
     *
     * 有关线程可以成为监视器所有者的方式的描述，请参阅 {@code notify} 方法。
     * See the {@code notify} method for a description of the ways in which a thread can become the owner of a monitor.
     *
     * 如果当前线程不是对象监视器的所有者, 抛出 IllegalMonitorStateException
     * @throws  IllegalMonitorStateException  if the current thread is not the owner of the object's monitor.
     *
     *
     * @throws  InterruptedException
     *      如果任何线程在当前线程等待通知之前或期间中断了当前线程, 抛出 InterruptedException
     *      if any thread interrupted the current thread before or while the current thread was waiting for a notification.
     *      抛出 InterruptedException 异常时清除当前线程的中断状态。
     *      The interrupted status of the current thread is cleared when this exception is thrown.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#notifyAll()
     */
    public final void wait() throws InterruptedException {
        wait(0);
    }

    /**
     * 导致当前线程等待，直到另一个线程调用该对象的{@link java.lang.Object#notify()}方法或{@link java.lang.Object#notifyAll()}方法，或者已经经过了指定的时间。
     * Causes the current thread to wait until either another thread invokes the {@link java.lang.Object#notify()} method or the {@link java.lang.Object#notifyAll()} method for this object, or a specified amount of time has elapsed.
     * <p>
     * 当前线程必须拥有该对象的监视器。
     * The current thread must own this object's monitor.
     * <p>
     * 此方法使当前线程（称为 T）将自己置于此对象的等待集中，然后放弃对该对象的任何和所有同步声明。
     * This method causes the current thread (call it <var>T</var>) to place itself in the wait set for this object and then to relinquish any and all synchronization claims on this object.
     *
     * 线程 T 出于线程调度目的而被禁用并处于休眠状态，直到发生以下四种情况之一: TODO 含义: 以下四种情况发生, 都会导致当前线程处于非休眠状态
     * Thread <var>T</var> becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:
     * <ul>
     * 其他一些线程为此对象调用 {@code notify} 方法，并且线程 T 恰好被任意选择为要唤醒的线程。
     * <li>Some other thread invokes the {@code notify} method for this object and thread <var>T</var> happens to be arbitrarily chosen as the thread to be awakened.
     * 其他一些线程为此对象调用 {@code notifyAll} 方法。
     * <li>Some other thread invokes the {@code notifyAll} method for this object.
     * 其他一些线程 {@linkplain Thread#interrupt() 中断} 线程 T。
     * <li>Some other thread {@linkplain Thread#interrupt() interrupts} thread <var>T</var>.
     * 或多或少已经过了指定的实时时间。
     * <li>The specified amount of real time has elapsed, more or less.
     *
     * 但是，如果 {@code timeout} 为零，则不考虑实时时间，线程只是等待直到通知。
     * If {@code timeout} is zero, however, then real time is not taken into consideration and the thread simply waits until notified.
     * </ul>
     * 线程 T 然后从该对象的等待集中移除，并重新启用线程调度。
     * The thread <var>T</var> is then removed from the wait set for this object and re-enabled for thread scheduling.
     *
     * 然后它以通常的方式与其他线程竞争在对象上同步的权利；
     * It then competes in the usual manner with other threads for the right to synchronize on the object;
     *
     * 一旦它获得了对象的控制权，它对对象的所有同步声明都将恢复到之前的状态——也就是说，恢复到调用 {@code wait} 方法时的情况。
     * once it has gained control of the object, all its synchronization claims on the object are restored to the status quo ante - that is, to the situation as of the time that the {@code wait} method was invoked.
     *
     * 然后线程 T 从 {@code wait} 方法的调用中返回。
     * Thread <var>T</var> then returns from the invocation of the {@code wait} method.
     *
     * 因此，从 {@code wait} 方法返回时，对象和线程 {@code T} 的同步状态与调用 {@code wait} 方法时完全相同。
     * Thus, on return from the {@code wait} method, the synchronization state of the object and of thread {@code T} is exactly as it was when the {@code wait} method was invoked.
     * <p>
     * 线程也可以在没有被通知、中断或超时的情况下唤醒，即所谓的<i>虚假唤醒</i>。
     * A thread can also wake up without being notified, interrupted, or timing out, a so-called <i>spurious wakeup</i>.
     *
     * 虽然这在实践中很少发生，但应用程序必须通过测试应该导致线程被唤醒的条件来防止它，如果条件不满足则继续等待。
     * While this will rarely occur in practice, applications must guard against it by testing for the condition that should have caused the thread to be awakened, and continuing to wait if the condition is not satisfied.
     *
     * 换句话说，等待应该总是在循环中发生，就像这样：
     * In other words, waits should always occur in loops, like this one:
     * <pre>
     *     synchronized (obj) {
     *         while (condition does not hold)  // 条件不成立
     *             obj.wait(timeout);
     *         ... // Perform action appropriate to condition   执行适合条件的操作
     *     }
     * </pre>
     * 有关此主题的更多信息，请参阅 Doug Lea 的“Java 中的并发编程（第二版）”（Addison-Wesley，2000 年）中的第 3.2.3 节或 Joshua Bloch 的“Effective Java Programming Language Guide”（Addison-Wesley , 2001)。
     * (For more information on this topic, see Section 3.2.3 in Doug Lea's "Concurrent Programming in Java (Second Edition)" (Addison-Wesley, 2000), or Item 50 in Joshua Bloch's "Effective Java Programming Language Guide" (Addison-Wesley, 2001).
     *
     * <p>
     * 如果当前线程是{@linkplain java.lang.Thread#interrupt() interrupt}被任何线程在等待之前或期间中断，则抛出{@code InterruptedException}。
     * If the current thread is {@linkplain java.lang.Thread#interrupt() interrupted} by any thread before or while it is waiting, then an {@code InterruptedException} is thrown.
     * 在按照上述方法恢复该对象的锁状态之前，不会引发此异常。
     * This exception is not thrown until the lock status of this object has been restored as described above.
     *
     * <p>
     * 请注意，{@code wait} 方法将当前线程放入此对象的等待集中，因此仅解锁此对象；
     * Note that the {@code wait} method, as it places the current thread into the wait set for this object, unlocks only this object;
     * 当前线程可能同步的任何其他对象在线程等待时保持锁定。
     * any other objects on which the current thread may be synchronized remain locked while the thread waits.
     * <p>
     * 此方法只能由作为此对象监视器所有者的线程调用。
     * This method should only be called by a thread that is the owner of this object's monitor.
     * 有关线程可以成为监视器所有者的方式的描述，请参阅 {@code notify} 方法。
     * See the {@code notify} method for a description of the ways in which a thread can become the owner of a monitor.
     *
     * 等待的最长时间（以毫秒为单位）。
     * @param   timeout                       the maximum time to wait in milliseconds.
     * 如果超时值为负。
     * @throws  IllegalArgumentException      if the value of timeout is negative.
     * 如果当前线程不是对象监视器的所有者。
     * @throws  IllegalMonitorStateException  if the current thread is not the owner of the object's monitor.
     *
     * @throws  InterruptedException
     *      如果任何线程在当前线程等待通知之前或期间中断了当前线程。
     *      if any thread interrupted the current thread before or while the current thread was waiting for a notification.
     *      抛出此异常时清除当前线程的中断状态。
     *      The interrupted status of the current thread is cleared when this exception is thrown.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#notifyAll()
     */
    public final native void wait(long timeout) throws InterruptedException;

    /**
     * 等待这个线程死亡。
     * Waits for this thread to die.
     *
     * <p>
     * 此方法的调用行为与调用完全相同
     * An invocation of this method behaves in exactly the same way as the invocation
     *
     * <blockquote> {@linkplain #join(long) join}{@code (0)}
     * </blockquote>
     *
     * @throws  InterruptedException
     *      如果任何线程中断了当前线程。
     *      if any thread has interrupted the current thread.
     *      抛出 InterruptedException 异常时清除当前线程的中断状态。
     *      The interrupted status of the current thread is cleared when this exception is thrown.
     */
    public final void join() throws InterruptedException {
        join(0);
    }

    /**
     * 唤醒在此对象的监视器上等待的单个线程。
     * Wakes up a single thread that is waiting on this object's monitor.
     * 如果有多个线程正在等待该对象，则选择其中一个线程被唤醒。
     * If any threads are waiting on this object, one of them is chosen to be awakened.
     * 选择是任意的，并且由实现决定。
     * The choice is arbitrary and occurs at the discretion of the implementation.
     * 线程通过调用 {@code wait} 方法之一 等待获取对象的监视器。
     * A thread waits on an object's monitor by calling one of the {@code wait} methods.
     * <p>
     * 被唤醒的线程将无法直接执行，直到当前线程放弃对该对象的锁定。
     * The awakened thread will not be able to proceed until the current thread relinquishes the lock on this object.
     * 被唤醒的线程将以通常的方式与可能正在积极竞争以同步此对象的任何其他线程进行竞争；
     * The awakened thread will compete in the usual manner with any other threads that might be actively competing to synchronize on this object;
     * 例如，被唤醒的线程在成为下一个锁定该对象的线程时没有可靠的特权或劣势。
     * for example, the awakened thread enjoys no reliable privilege or disadvantage in being the next thread to lock this object.
     * <p>
     * 此方法只能由作为此对象监视器所有者的线程调用。
     * This method should only be called by a thread that is the owner of this object's monitor.
     * 线程通过以下三种方式之一成为对象监视器的所有者：
     * A thread becomes the owner of the object's monitor in one of three ways:
     * <ul>
     * 通过执行该对象的同步实例方法。
     * <li>By executing a synchronized instance method of that object.
     * 通过执行在对象上同步的 {@code synchronized} 语句的主体。
     * <li>By executing the body of a {@code synchronized} statement that synchronizes on the object.
     * 对于 {@code Class,} 类型的对象，通过执行该类的同步静态方法。
     * <li>For objects of type {@code Class,} by executing a synchronized static method of that class.
     * </ul>
     *
     * <p>
     * 一次只有一个线程可以拥有一个对象的监视器。
     * Only one thread at a time can own an object's monitor.
     *
     * 如果当前线程不是对象监视器的所有者。
     * @throws  IllegalMonitorStateException  if the current thread is not the owner of this object's monitor.
     * @see        java.lang.Object#notifyAll()
     * @see        java.lang.Object#wait()
     */
    public final native void notify();

    /**
     * 唤醒在此对象监视器上等待的所有线程。
     * Wakes up all threads that are waiting on this object's monitor.
     * 线程通过调用 {@code wait} 方法之一在对象的监视器上等待。
     * A thread waits on an object's monitor by calling one of the {@code wait} methods.
     * <p>
     * 被唤醒的线程将以通常的方式与可能正在积极竞争以同步此对象的任何其他线程进行竞争；
     * The awakened threads will not be able to proceed until the current thread relinquishes the lock on this object.
     * 例如，被唤醒的线程在成为下一个锁定该对象的线程时不享有可靠的特权或劣势。
     * The awakened threads will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened threads enjoy no reliable privilege or disadvantage in being the next thread to lock this object.
     * <p>
     * 此方法只能由作为此对象监视器所有者的线程调用。
     * This method should only be called by a thread that is the owner of this object's monitor.
     * 有关线程可以成为监视器所有者的方式的描述，请参阅 {@code notify} 方法。
     * See the {@code notify} method for a description of the ways in which a thread can become the owner of a monitor.
     *
     * 如果当前线程不是对象监视器的所有者。
     * @throws  IllegalMonitorStateException  if the current thread is not the owner of this object's monitor.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#wait()
     */
    public final native void notifyAll();

    TODO wait(), wait(long timeout), notify(), notifyAll() 这些方法 必须满足 当前线程是对象监视器的所有者

    notify()    表示 唤醒 当前线程所持有 对象监听器的 阻塞队列中的 一个线程!
    notifyAll() 表示 唤醒 当前线程所持有 对象监听器的 阻塞队列中的 所有线程!

等待线程执行中止的方法 join()
    thread.join() 上面的源码中 表示 等待当前线程死亡!
    现实生活中这个用的比较多, 例如 线程A 加载 数据A + 线程B 加载 数据B --> 计算 数据A 和 数据B --> 得出结果! 这就需要 线程A 和 线程B 都必须 完成 才能继续 接下来的 任务, 这时就需要 用到 Thread.join() 方法了

让线程睡眠的方法 sleep()

    /**
     * 使当前正在执行的线程休眠（暂时停止执行）指定的毫秒数，取决于系统计时器和调度程序的精度和准确性。
     * Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds, subject to the precision and accuracy of system timers and schedulers.
     *
     * 该线程不会失去任何监视器的所有权。TODO 释放cpu资源, 不释放锁!
     * The thread does not lose ownership of any monitors.
     *
     * @param  millis
     *         以毫秒为单位的睡眠时间长度
     *         the length of time to sleep in milliseconds
     *
     * @throws  IllegalArgumentException
     *          如果 {@code millis} 的值为负
     *          if the value of {@code millis} is negative
     *
     * @throws  InterruptedException
     *          如果任何线程中断了当前线程。
     *          if any thread has interrupted the current thread.
     *          抛出此异常时清除当前线程的中断状态。
     *          The interrupted status of the current thread is cleared when this exception is thrown.
     */
    public static native void sleep(long millis) throws InterruptedException;

让CPU让出执行权的方法 yield()

