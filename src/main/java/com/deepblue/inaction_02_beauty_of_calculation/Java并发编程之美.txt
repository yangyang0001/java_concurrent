------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------- 第1章 并发编程线程基础 ----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------
进程: 是系统进行资源分配和调度的 单位正交基!
线程: 是CPU资源分配和调度的 单位正交基!

实现线程的三种方法:
    1、继承Thread
    2、实现Runnable
    3、实现Callable 进而实现 FutrueTask 来实现自己的线程

线程通知和等待 wait(), notify(), notifyAll()
    虚假唤醒:
    一个线程从 挂起状态 变成 可运行状态, 这个过程称为唤醒;  线程A可能就该轮到他执行了, 并没有经过 其他线程B 的 notify(), notifyAll() 方法 进行唤醒, 这种就是典型的 虚假唤醒!

    防止虚假唤醒的方式:
    锁住的执行代码块之内使用, 一直判定的 满足条件才 wait()

    // 非常核心的使用方式: 是obj
    使用规范如下:
    synchronized(obj) {
        while(不满足获取 obj 监视器的条件) {
            obj.wait();
        }
        ...
        obj.notify();
    }

    或

    synchronized(obj) {
        while(不满足获取 obj 监视器的条件) {
            obj.wait();
        }
        ...
        obj.notifyAll();
    }

    源码解析:
    /**
     * TODO 使当前线程进入等待状态
     * 使当前线程等待，直到另一个线程为此对象调用 {@link java.lang.Object#notify()} 方法或 {@link java.lang.Object#notifyAll()} 方法。
     * Causes the current thread to wait until another thread invokes the {@link java.lang.Object#notify()} method or the {@link java.lang.Object#notifyAll()} method for this object.
     *
     * 换句话说，这个方法的行为就像它只是执行调用 {@code wait(0)} 一样。
     * In other words, this method behaves exactly as if it simply performs the call {@code wait(0)}.
     * <p>
     * 当前线程必须拥有此对象的监视器。
     * The current thread must own this object's monitor.
     *
     * 线程释放此监视器的所有权并等待，直到另一个线程通知在此对象监视器上等待的线程通过调用 {@code notify} 方法或 {@code notifyAll} 方法唤醒。
     * The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object's monitor to wake up either through a call to the {@code notify} method or the {@code notifyAll} method.
     *
     * 然后线程等待直到它可以重新获得监视器的所有权并恢复执行。
     * The thread then waits until it can re-obtain ownership of the monitor and resumes execution.
     * <p>
     * 与单参数版本一样，中断和虚假唤醒是可能的，并且应始终在循环中使用此方法：
     * As in the one argument version, interrupts and spurious wakeups are possible, and this method should always be used in a loop:
     * <pre>
     *     synchronized (obj) {
     *         while (condition does not hold)  // 条件不成立
     *             obj.wait();
     *         ... // Perform action appropriate to condition   执行适合条件的动作
     *     }
     * </pre>
     * 此方法只能由作为此对象监视器所有者的线程调用。
     * This method should only be called by a thread that is the owner of this object's monitor.
     *
     * 有关线程可以成为监视器所有者的方式的描述，请参阅 {@code notify} 方法。
     * See the {@code notify} method for a description of the ways in which a thread can become the owner of a monitor.
     *
     * 如果当前线程不是对象监视器的所有者, 抛出 IllegalMonitorStateException
     * @throws  IllegalMonitorStateException  if the current thread is not the owner of the object's monitor.
     *
     *
     * @throws  InterruptedException
     *      如果任何线程在当前线程等待通知之前或期间中断了当前线程, 抛出 InterruptedException
     *      if any thread interrupted the current thread before or while the current thread was waiting for a notification.
     *      抛出 InterruptedException 异常时清除当前线程的中断状态。
     *      The interrupted status of the current thread is cleared when this exception is thrown.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#notifyAll()
     */
    public final void wait() throws InterruptedException {
        wait(0);
    }

    /**
     * 导致当前线程等待，直到另一个线程调用该对象的{@link java.lang.Object#notify()}方法或{@link java.lang.Object#notifyAll()}方法，或者已经经过了指定的时间。
     * Causes the current thread to wait until either another thread invokes the {@link java.lang.Object#notify()} method or the {@link java.lang.Object#notifyAll()} method for this object, or a specified amount of time has elapsed.
     * <p>
     * 当前线程必须拥有该对象的监视器。
     * The current thread must own this object's monitor.
     * <p>
     * 此方法使当前线程（称为 T）将自己置于此对象的等待集中，然后放弃对该对象的任何和所有同步声明。
     * This method causes the current thread (call it <var>T</var>) to place itself in the wait set for this object and then to relinquish any and all synchronization claims on this object.
     *
     * 线程 T 出于线程调度目的而被禁用并处于休眠状态，直到发生以下四种情况之一: TODO 含义: 以下四种情况发生, 都会导致当前线程处于非休眠状态
     * Thread <var>T</var> becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:
     * <ul>
     * 其他一些线程为此对象调用 {@code notify} 方法，并且线程 T 恰好被任意选择为要唤醒的线程。
     * <li>Some other thread invokes the {@code notify} method for this object and thread <var>T</var> happens to be arbitrarily chosen as the thread to be awakened.
     * 其他一些线程为此对象调用 {@code notifyAll} 方法。
     * <li>Some other thread invokes the {@code notifyAll} method for this object.
     * 其他一些线程 {@linkplain Thread#interrupt() 中断} 线程 T。
     * <li>Some other thread {@linkplain Thread#interrupt() interrupts} thread <var>T</var>.
     * 或多或少已经过了指定的实时时间。
     * <li>The specified amount of real time has elapsed, more or less.
     *
     * 但是，如果 {@code timeout} 为零，则不考虑实时时间，线程只是等待直到通知。
     * If {@code timeout} is zero, however, then real time is not taken into consideration and the thread simply waits until notified.
     * </ul>
     * 线程 T 然后从该对象的等待集中移除，并重新启用线程调度。
     * The thread <var>T</var> is then removed from the wait set for this object and re-enabled for thread scheduling.
     *
     * 然后它以通常的方式与其他线程竞争在对象上同步的权利；
     * It then competes in the usual manner with other threads for the right to synchronize on the object;
     *
     * 一旦它获得了对象的控制权，它对对象的所有同步声明都将恢复到之前的状态——也就是说，恢复到调用 {@code wait} 方法时的情况。
     * once it has gained control of the object, all its synchronization claims on the object are restored to the status quo ante - that is, to the situation as of the time that the {@code wait} method was invoked.
     *
     * 然后线程 T 从 {@code wait} 方法的调用中返回。
     * Thread <var>T</var> then returns from the invocation of the {@code wait} method.
     *
     * 因此，从 {@code wait} 方法返回时，对象和线程 {@code T} 的同步状态与调用 {@code wait} 方法时完全相同。
     * Thus, on return from the {@code wait} method, the synchronization state of the object and of thread {@code T} is exactly as it was when the {@code wait} method was invoked.
     * <p>
     * 线程也可以在没有被通知、中断或超时的情况下唤醒，即所谓的<i>虚假唤醒</i>。
     * A thread can also wake up without being notified, interrupted, or timing out, a so-called <i>spurious wakeup</i>.
     *
     * 虽然这在实践中很少发生，但应用程序必须通过测试应该导致线程被唤醒的条件来防止它，如果条件不满足则继续等待。
     * While this will rarely occur in practice, applications must guard against it by testing for the condition that should have caused the thread to be awakened, and continuing to wait if the condition is not satisfied.
     *
     * 换句话说，等待应该总是在循环中发生，就像这样：
     * In other words, waits should always occur in loops, like this one:
     * <pre>
     *     synchronized (obj) {
     *         while (condition does not hold)  // 条件不成立
     *             obj.wait(timeout);
     *         ... // Perform action appropriate to condition   执行适合条件的操作
     *     }
     * </pre>
     * 有关此主题的更多信息，请参阅 Doug Lea 的“Java 中的并发编程（第二版）”（Addison-Wesley，2000 年）中的第 3.2.3 节或 Joshua Bloch 的“Effective Java Programming Language Guide”（Addison-Wesley , 2001)。
     * (For more information on this topic, see Section 3.2.3 in Doug Lea's "Concurrent Programming in Java (Second Edition)" (Addison-Wesley, 2000), or Item 50 in Joshua Bloch's "Effective Java Programming Language Guide" (Addison-Wesley, 2001).
     *
     * <p>
     * 如果当前线程是{@linkplain java.lang.Thread#interrupt() interrupt}被任何线程在等待之前或期间中断，则抛出{@code InterruptedException}。
     * If the current thread is {@linkplain java.lang.Thread#interrupt() interrupted} by any thread before or while it is waiting, then an {@code InterruptedException} is thrown.
     * 在按照上述方法恢复该对象的锁状态之前，不会引发此异常。
     * This exception is not thrown until the lock status of this object has been restored as described above.
     *
     * <p>
     * 请注意，{@code wait} 方法将当前线程放入此对象的等待集中，因此仅解锁此对象；
     * Note that the {@code wait} method, as it places the current thread into the wait set for this object, unlocks only this object;
     * 当前线程可能同步的任何其他对象在线程等待时保持锁定。
     * any other objects on which the current thread may be synchronized remain locked while the thread waits.
     * <p>
     * 此方法只能由作为此对象监视器所有者的线程调用。
     * This method should only be called by a thread that is the owner of this object's monitor.
     * 有关线程可以成为监视器所有者的方式的描述，请参阅 {@code notify} 方法。
     * See the {@code notify} method for a description of the ways in which a thread can become the owner of a monitor.
     *
     * 等待的最长时间（以毫秒为单位）。
     * @param   timeout                       the maximum time to wait in milliseconds.
     * 如果超时值为负。
     * @throws  IllegalArgumentException      if the value of timeout is negative.
     * 如果当前线程不是对象监视器的所有者。
     * @throws  IllegalMonitorStateException  if the current thread is not the owner of the object's monitor.
     *
     * @throws  InterruptedException
     *      如果任何线程在当前线程等待通知之前或期间中断了当前线程。
     *      if any thread interrupted the current thread before or while the current thread was waiting for a notification.
     *      抛出此异常时清除当前线程的中断状态。
     *      The interrupted status of the current thread is cleared when this exception is thrown.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#notifyAll()
     */
    public final native void wait(long timeout) throws InterruptedException;

    /**
     * 等待这个线程死亡。
     * Waits for this thread to die.
     *
     * <p>
     * 此方法的调用行为与调用完全相同
     * An invocation of this method behaves in exactly the same way as the invocation
     *
     * <blockquote> {@linkplain #join(long) join}{@code (0)}
     * </blockquote>
     *
     * @throws  InterruptedException
     *      如果任何线程中断了当前线程。
     *      if any thread has interrupted the current thread.
     *      抛出 InterruptedException 异常时清除当前线程的中断状态。
     *      The interrupted status of the current thread is cleared when this exception is thrown.
     */
    public final void join() throws InterruptedException {
        join(0);
    }

    /**
     * 唤醒在此对象的监视器上等待的单个线程。
     * Wakes up a single thread that is waiting on this object's monitor.
     * 如果有多个线程正在等待该对象，则选择其中一个线程被唤醒。
     * If any threads are waiting on this object, one of them is chosen to be awakened.
     * 选择是任意的，并且由实现决定。
     * The choice is arbitrary and occurs at the discretion of the implementation.
     * 线程通过调用 {@code wait} 方法之一 等待获取对象的监视器。
     * A thread waits on an object's monitor by calling one of the {@code wait} methods.
     * <p>
     * 被唤醒的线程将无法直接执行，直到当前线程放弃对该对象的锁定。
     * The awakened thread will not be able to proceed until the current thread relinquishes the lock on this object.
     * 被唤醒的线程将以通常的方式与可能正在积极竞争以同步此对象的任何其他线程进行竞争；
     * The awakened thread will compete in the usual manner with any other threads that might be actively competing to synchronize on this object;
     * 例如，被唤醒的线程在成为下一个锁定该对象的线程时没有可靠的特权或劣势。
     * for example, the awakened thread enjoys no reliable privilege or disadvantage in being the next thread to lock this object.
     * <p>
     * 此方法只能由作为此对象监视器所有者的线程调用。
     * This method should only be called by a thread that is the owner of this object's monitor.
     * 线程通过以下三种方式之一成为对象监视器的所有者：
     * A thread becomes the owner of the object's monitor in one of three ways:
     * <ul>
     * 通过执行该对象的同步实例方法。
     * <li>By executing a synchronized instance method of that object.
     * 通过执行在对象上同步的 {@code synchronized} 语句的主体。
     * <li>By executing the body of a {@code synchronized} statement that synchronizes on the object.
     * 对于 {@code Class,} 类型的对象，通过执行该类的同步静态方法。
     * <li>For objects of type {@code Class,} by executing a synchronized static method of that class.
     * </ul>
     *
     * <p>
     * 一次只有一个线程可以拥有一个对象的监视器。
     * Only one thread at a time can own an object's monitor.
     *
     * 如果当前线程不是对象监视器的所有者。
     * @throws  IllegalMonitorStateException  if the current thread is not the owner of this object's monitor.
     * @see        java.lang.Object#notifyAll()
     * @see        java.lang.Object#wait()
     */
    public final native void notify();

    /**
     * 唤醒在此对象监视器上等待的所有线程。
     * Wakes up all threads that are waiting on this object's monitor.
     * 线程通过调用 {@code wait} 方法之一在对象的监视器上等待。
     * A thread waits on an object's monitor by calling one of the {@code wait} methods.
     * <p>
     * 被唤醒的线程将以通常的方式与可能正在积极竞争以同步此对象的任何其他线程进行竞争；
     * The awakened threads will not be able to proceed until the current thread relinquishes the lock on this object.
     * 例如，被唤醒的线程在成为下一个锁定该对象的线程时不享有可靠的特权或劣势。
     * The awakened threads will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened threads enjoy no reliable privilege or disadvantage in being the next thread to lock this object.
     * <p>
     * 此方法只能由作为此对象监视器所有者的线程调用。
     * This method should only be called by a thread that is the owner of this object's monitor.
     * 有关线程可以成为监视器所有者的方式的描述，请参阅 {@code notify} 方法。
     * See the {@code notify} method for a description of the ways in which a thread can become the owner of a monitor.
     *
     * 如果当前线程不是对象监视器的所有者。
     * @throws  IllegalMonitorStateException  if the current thread is not the owner of this object's monitor.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#wait()
     */
    public final native void notifyAll();

    TODO wait(), wait(long timeout), notify(), notifyAll() 这些方法 必须满足 当前线程是对象监视器的所有者

    notify()    表示 唤醒 当前线程所持有 对象监听器的 阻塞队列中的 一个线程!
    notifyAll() 表示 唤醒 当前线程所持有 对象监听器的 阻塞队列中的 所有线程!

等待线程执行中止的方法 join()
    thread.join() 上面的源码中 表示 等待当前线程死亡!
    现实生活中这个用的比较多, 例如 线程A 加载 数据A + 线程B 加载 数据B --> 计算 数据A 和 数据B --> 得出结果! 这就需要 线程A 和 线程B 都必须 完成 才能继续 接下来的 任务, 这时就需要 用到 Thread.join() 方法了

让线程睡眠的方法 sleep()

    /**
     * 使当前正在执行的线程休眠（暂时停止执行）指定的毫秒数，取决于系统计时器和调度程序的精度和准确性。
     * Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds, subject to the precision and accuracy of system timers and schedulers.
     *
     * 该线程不会失去任何监视器的所有权。TODO 释放cpu资源, 不释放锁!
     * The thread does not lose ownership of any monitors.
     *
     * @param  millis
     *         以毫秒为单位的睡眠时间长度
     *         the length of time to sleep in milliseconds
     *
     * @throws  IllegalArgumentException
     *          如果 {@code millis} 的值为负
     *          if the value of {@code millis} is negative
     *
     * @throws  InterruptedException
     *          如果任何线程中断了当前线程。
     *          if any thread has interrupted the current thread.
     *          抛出此异常时清除当前线程的中断状态。
     *          The interrupted status of the current thread is cleared when this exception is thrown.
     */
    public static native void sleep(long millis) throws InterruptedException;

让CPU让出执行权的方法 yield()

    源码解析:
    /**
     * 向调度程序提示当前线程愿意让出 ts 当前使用的处理器。
     * A hint to the scheduler that the current thread is willing to yield ts current use of a processor.
     * 调度程序可以随意忽略此提示。
     * The scheduler is free to ignore this hint.
     *
     * <p>
     * Yield 是一种启发式尝试，旨在改善线程之间的相对进展，否则会过度使用 CPU。
     * Yield is a heuristic attempt to improve relative progression between threads that would otherwise over-utilise a CPU.
     * 它的使用应与详细的分析和基准测试相结合，以确保它确实具有预期的效果。
     * Its use should be combined with detailed profiling and benchmarking to ensure that it actually has the desired effect.
     *
     * <p>
     * 很少适合使用这种方法。
     * It is rarely appropriate to use this method.
     * 它对于调试或测试目的可能很有用，它可能有助于重现由于竞争条件引起的错误。
     * It may be useful for debugging or testing purposes, where it may help to reproduce bugs due to race conditions.
     * 在设计并发控制结构（例如 {@link java.util.concurrent.locks} 包中的结构）时，它也可能很有用。
     * It may also be useful when designing concurrency control constructs such as the ones in the {@link java.util.concurrent.locks} package.
     */
    public static native void yield();

线程中断
    线程中断是线程之间的一种写作模式, 线程中断是根据当前线程中断标识来进行自行处理的, 这种处理极有可能不是立即执行的!
    源码解析: interrupt();
    /**
     * 中断此线程
     * Interrupts this thread.
     *
     * <p>
     * 除非当前线程自己中断，这总是被允许的，否则会调用此线程的 {@link #checkAccess() checkAccess} 方法，这可能会导致抛出 {@link SecurityException}。
     * Unless the current thread is interrupting itself, which is always permitted, the {@link #checkAccess() checkAccess} method of this thread is invoked, which may cause a {@link SecurityException} to be thrown.
     *
     * <p>
     * 如果此线程在调用中被阻塞
     * If this thread is blocked in an invocation
     * 调用了Object类的 wait(), wait(long), wait(long, int)
     * of the {@link Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link Object#wait(long, int) wait(long, int)} methods of the {@link Object} class,
     * 调用了Thread类的 join(), join(long), sleep(long), sleep(long, int)
     * or of the {@link #join()}, {@link #join(long)}, {@link #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)}, methods of this class,
     * 那么它的中断状态将被清除，并且它会收到一个 {@link InterruptedException}。
     * then its interrupt status will be cleared and it will receive an {@link InterruptedException}.
     *
     * <p>
     * 如果此线程在 {@link java.nio.channels.InterruptibleChannel InterruptibleChannel} 上的 I/O 操作中被阻塞，则通道将关闭，线程的中断状态将被设置，线程将收到一个 {@link java .nio.channels.ClosedByInterruptException}。
     * If this thread is blocked in an I/O operation upon an {@link java.nio.channels.InterruptibleChannel InterruptibleChannel} then the channel will be closed, the thread's interrupt status will be set, and the thread will receive a {@link java.nio.channels.ClosedByInterruptException}.
     *
     * <p> TODO java.nio.channels.Selector 需要看 netty
     * 如果此线程在 {@link java.nio.channels.Selector} 中被阻塞，则该线程的中断状态将被设置，并且它将立即从选择操作中返回，可能具有非零值，就像选择器的 { @link java.nio.channels.Selector#wakeup wakeup} 方法被调用。
     * If this thread is blocked in a {@link java.nio.channels.Selector} then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector's {@link java.nio.channels.Selector#wakeup wakeup} method were invoked.
     *
     * <p>
     * 如果前面的条件都不成立，则将设置此线程的中断状态。
     * If none of the previous conditions hold then this thread's interrupt status will be set.
     *
     * <p>
     * 中断一个不活跃的线程不需要有任何影响。
     * Interrupting a thread that is not alive need not have any effect.
     *
     * @throws  SecurityException
     *          if the current thread cannot modify this thread     // 如果当前线程不能修改这个线程
     *
     * @revised 6.0
     * @spec JSR-51
     */
    public void interrupt() {
        if (this != Thread.currentThread())
            checkAccess();

        synchronized (blockerLock) {
            Interruptible b = blocker;
            if (b != null) {
                interrupt0();           // Just to set the interrupt flag   只是为了设置中断标志
                b.interrupt(this);
                return;
            }
        }
        interrupt0();
    }

    /**
     * 测试此线程是否已被中断。
     * Tests whether this thread has been interrupted.
     * 线程的中断状态不受此方法的影响。
     * The interrupted status of the thread is unaffected by this method.
     *
     * <p>
     * 由于线程在中断时不处于活动状态而被忽略的线程中断将通过此方法返回 false 来反映。 TODO 如果线程不处于活跃状态 则返回 false
     * A thread interruption ignored because a thread was not alive at the time of the interrupt will be reflected by this method returning false.
     *
     * @return  <code>true</code> if this thread has been interrupted;  // 当前线程处于中断状态   返回 true
     *          <code>false</code> otherwise.                           // 当前线程处于非中断状态 返回 false
     * @see     #interrupted()
     * @revised 6.0
     */
    public boolean isInterrupted() {
        return isInterrupted(false);
    }

    /**
     * 测试某个线程是否已被中断。
     * Tests if some Thread has been interrupted.
     * 中断状态是否根据传递的 ClearInterrupted 值重置。
     * The interrupted state is reset or not based on the value of ClearInterrupted that is passed.
     */
    private native boolean isInterrupted(boolean ClearInterrupted);

    Thread.interrupted() 方法 源码解析:
    /**
     * 测试当前线程是否被中断。
     * Tests whether the current thread has been interrupted.
     * 通过该方法清除线程的中断状态。
     * The interrupted status of the thread is cleared by this method.
     * 换句话说，如果这个方法被连续调用两次，第二次调用将返回 false（除非当前线程再次被中断，在第一次调用清除其中断状态之后，第二次调用检查它之前）。
     * In other words, if this method were to be called twice in succession, the second call would return false (unless the current thread were interrupted again, after the first call had cleared its interrupted status and before the second call had examined it).
     *
     * <p>
     * 由于线程在中断时不处于活动状态而被忽略的线程中断将通过此方法返回 false 来反映。 TODO 如果线程不处于活跃状态 则返回 false
     * A thread interruption ignored because a thread was not alive at the time of the interrupt will be reflected by this method returning false.
     *
     * @return  <code>true</code> if the current thread has been interrupted;   // 当前线程处于中断状态   返回 true
     *          <code>false</code> otherwise.                                   // 当前线程不处于中断状态 返回 false
     * @see #isInterrupted()
     * @revised 6.0
     */
    public static boolean interrupted() {
        return currentThread().isInterrupted(true);
    }

    线程优雅退出的代码如下: 这里的退出指的是退出正常工作
    if(!Thread.currentThread().isInterrupted() && do more work) {
        // do more work
    } else {
        // 中断 或 没有更多工作 要做 则 进入优雅退出 分支!
    }

线程上下文的切换
    线程上线文的切换时机: 当CPU不执行当前线程, 转而执行其他线程的时候!

线程死锁:
    什么是线程死锁?

线程的种类
    守护线程(daemon) 和 用户线程(user)
    JVM 的关闭 不受 守护线程的 影响, 设置方式为 在 start() 方法之前使用 setDaemon(true) 方法就OK了
    JVM 的关闭 受到 用户线程的 影响, 一旦所有用户线程都执行完毕, 无论是否还有守护线程存活, JVM 都将关闭!

ThreadLocal:
    不可以继承的 ThreadLocalMap 为 Thread 类中的 threadLocals 变量;             子线程 不能获取到 父线程的 ThreadLocalMap 中的值
    可以继承的的 ThreadLocalMap 为 Thread 类中的 inheritableThreadLocals 变量   子线程 能够获取到 父线程的 ThreadLocalMap 中的值

------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------- 第2章 并发编程的其他基础知识 --------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------
并发和并行
    并发: 是指 单CPU 某个时间段内 有多个线程交替执行 查看 并发图示.png
    并行: 是指 多CPU 某个时间点上 有多个线程同时执行 查看 并行图示.png

    因为我们开发中的所用到的线程是多于CPU个数的, 所以我们称之为 多线程并发编程!

为什么我们要学习并发编程
    因为随着硬件系统CPU的个数越来越多 且 有海量数据汇总的需求, 导致我们要更加充分利用CPU资源, 这样并发编程就变成了一种迫切需要了!

线程安全问题
    共享资源 是指 有多个线程 共同使用的资源
    线程安全问题 是指 多个线程对 共享资源 同时读写的情况下会出现脏数据或其他不可预料的结果

synchronized 关键字
    是监视器锁, 对象锁, 排它锁 使用 synchronized 会有线程上下文的切换!

volatile 关键字
    不使用 volatile 关键字时
        共享数据的传递过程: 线程使用CPU计算主内存中的共享资源, 会将 从主内存共享变量中获取的值 刷新至 L2 Cache, L1 Cache 然后经过 CPU 运算器计算, 将计算完成的结果 重新刷新 到 L1 Cache, L2 Cache 最后刷新至 主内存中!
        带来的问题: 共享变量不使用 volatile 关键字时, 多个线程会在 L1 Cache, L2 Cache 中 直接命中, 这样就会造成 多线程之间共享变量的更改是不可见的!
    使用 volatile 关键字时
        共享数据的传递过程: 线程使用CPU计算主内存中的共享资源, 不会将数据刷新至任何Cache或其他地方, CPU直接从主内存中获取数据, 不会从缓存中命中, 这样任何共享资源的变更对于其他线程而言, 是可见的!
        使用volatitle 只能保证可见性, 不能保证安全性! 因为数据虽然可见, 并不能保证CPU计算后能立即刷新会主内存, 这样会造成数据安全问题!
    总结:
        使用　 volatile时, CPU计算的共享数据 只和 堆中的主内存进行交互!
        不使用 volatile时, CPU计算的共享数据 要和 L1 Cache, L2 Cache, 主内存 进行数据交互!

java中的原子性操作
    原子性操作的提出, 对于一个共享变量来说 如果存在 读取-计算-回写 的过程, 一旦这个过程不是原子性的, 那么就存在数据的安全性!

    com.deepblue.inaction_02_beauty_of_calculation.chapter_02_safe.example_003.Count
    经过 javap -verbose D:\study_workspace\java_concurrent\target\classes\com\deepblue\inaction_02_beauty_of_calculation\chapter_02_safe\example_003\Count.class
    increment() 方法的 Code码 如下:

     0 aload_0
     1 dup
     2 getfield #2 <com/deepblue/inaction_02_beauty_of_calculation/chapter_02_safe/example_003/Count.count>
     5 lconst_1
     6 ladd
     7 putfield #2 <com/deepblue/inaction_02_beauty_of_calculation/chapter_02_safe/example_003/Count.count>
    10 return

    对于 count++; 包含的指令为 2,5,6,7 因此 count++; 在使用时原子性无法保证, 这样就不能保证数据的安全性!

Java 中的 CAS 操作 是依赖 UnSafe 类进行的
    CAS 操作有个 ABA 的问题
        线程I 获取变量 X 的值为 A, 假设要将 变量X 的值 由A变为B, 在此刻 线程II 获取到变量X 执行 CAS 操作 将A变为了B, 紧接着由B 再执行 CAS操作 变成了 A, 这是 线程I 执行CAS 操作 变成B
        虽然是我们想要的结果B, 但是这里面 线程II 操作了流程将 变量X 由 A -> B -> A 的操作, 线程I 并不知道, 里面的状态改变了, 这就是ABA的问题!

UnSafe类 可以查看 UnSafe.java 类的翻译

指令重排问题
    多线程指令重排问题, 这个为题会引起数据安全问题! volatile 就避免的指令重排问题
    当 volatile 变量写入时, 可确保 volatile 变量写入之前的操作 不会 重排到 volatile 变量写入之后
    当 volatile 变量读取时, 可确保 volatile 变量读取之后的操作 不会 重排到 volatile 变量读取之前

伪共享
    CPU 和 主内存交互的基本单位
        CPU 缓存一般分为 L1 Cache 和 L2 Cache(多CPU共享缓存), CPU 缓存 和 主内存之间 进行交互的 基本单位 是 缓存行(Cache Line)

    Cache Line 的大小
        缓存行的大小一般是 2的幂次倍 字节数

    Cache Line 内存存放了啥
        缓存行内存存放了 多个变量

    Cache Line 要符合 缓存一致性协议

    伪共享出现的原因
        因为CPU缓存 和 主内存之间的交互是比较慢的(相对而言), 为了提高线程的处理速度, 这就要求 读取主内存中的数据时, 往往读取连续的一块空间(这块空间和缓存行大小一致), 造成多个变量 共享一个缓存行!

    伪共享出现的问题
        当多个线程同时修改 同一个缓存行中的不同变量时, 存在缓存行竞争的问题, 造成效率下降!

    如何避免伪共享
        使用注解 @sun.misc.Contended, 因为 伪共享的注解 只是用于 rt 包里面的类, 如果我们使用 我们需要 添加 VMOption -XX:-RestrictContended, 填充默认宽度为 128
        这里的 RestrictContended 是 伪共享的意思, 默认情况下是开启的

锁的概述
    乐观锁和悲观锁
        悲观锁 获取时就认定有并发问题, 修改时不做限制
        乐观锁 获取时假设没有并发问题, 只有在修改时 特别处理一下

        悲观锁的伪代码举例如下:
        public int updateEntry(long id) {   // 此方法加上 事务性操作
            // 查询某个对象
            EntryObject entry = query("select * from table where id = #{} for update", id);
            ......
            // 设置对象中的属性
            entry.setXXX(...);
            ......
            // 执行修改操作
            int count = update("update table set name = #{name}, age = #{age} where id = #{id}", entry);
            return count;
        }
        当多个线程调用 updateEntry(long id) 方法时, 如果已经有线程获取到 id = #{id} 的 数据记录, 并在执行 updateEntry(long id) 方法中
        则当前线程因获取不到 id = #{id} 的纪录锁, 而获取不到对象 而造成阻塞

        乐观锁的伪代码举例如下:
        public int updateEntry(long id) { // 此方法上 加上 事务性操作
            // 查询某个对象
            EntryObject entry = query("select * from table where id = #{id}", id);
            ......
            // 设置对象中的属性
            entry.setXXX(...);
            entry.setNewVersion(entry.getVersion() + 1);
            ......
            // 执行修改操作
            int count = update("update table set name = #{name}, age = #{age}, version = #{newVersion}
            where id = #{id} and version = #{version}", entry);
            return count;
        }
        乐观锁重试的代码写法如下:
        public int updateEntry(long id) {
            int count = 5;
            int result = 0;
            while(count > 0) {
                // 查询某个对象
                EntryObject entry = query("select * from table where id = #{id}", id);
                ......
                // 设置对象的属性
                entry.setXXX(...);
                entry.setNewVersion(entry.getVersion() + 1);
                ......
                // 执行修改操作
                result = update("update table set name = #{name}, age = #{age}, version = #{newVersion} where id = #{id} and version = #{version}", entry);
                if(result > 0) {
                    return result;
                }
                count --;
            }

            return result;
        }

        总结: 悲观锁极有可能产生死锁, 因为他使用了 数据库的纪录锁! 乐观锁永远不会产生死锁, 因为从头至尾都没有使用过 数据库锁的机制!

公平锁和非公平锁
    所谓公平和不公平是根据 线程的等待时间来进行判定的, 如果先来先得 这就是 公平锁! 先来未必先得可以进行插队, 这就是 非公平锁!
    使用方式推荐: 在无特殊使说明的情况下, 尽量多使用非公平锁, 因为公平锁是非常消耗性能的(相对非公平锁来说)

独占锁和共享锁
    独占锁: 在任何使用当前所只能由一个线程持有, 这种锁称之为独占锁!
    共享锁: 当前锁可以被多个线程共同持有, 这种锁就称之为共享锁!

可重入锁
    可重入锁 往往只一个线程, 在线程已经获取到锁A并再次获取锁A, 我们就称 锁A 为可重入锁! synchronized 锁是可重入锁!

自旋锁
    如果线程A尝试获取锁时 发现锁已经被 其他线程占有, 此时线程A并不立即进入阻塞状态, 而是占用CPU时间多次尝试获取该锁, 在尝试获取锁的时候可能其他线程已经释放了锁, 那么会造成 CPU执行时间是白白浪费的!
    这种尝试获取次数最多为10次, 如果一直没有获取到 则线程A进行阻塞

------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------ 第3章 ThreadLocalRandom类的解析 -----------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------
Random 源码解析
    参考 Random.java 翻译后的 nextInt(int bound) 内核是一个 AtomicLong 它是个公共资源, 是线程安全的!
    如果出现多线程, 这块只能有一个线程成功, 不成功的则 进行自旋 执行 CompareAndSet 操作, 直到成功为止, 一旦出现多线程自旋, 则会浪费 CPU 资源!

ThreadLocalRandom 类似于 ThreadLocal; 避免了 Random 中 AtomicLong 的原子性操作, 这样就避免了多线程 对 AtomicLong 公共资源的竞争

------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------- 第4章 Java并发包中 原子操作类 的原理剖析 -------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------
JDK 中的 JUC 包下的类, 都是采用 CAS 实现的, 相比于使用锁实现原子性操作 从性能上提高很多!

原子变量操作类 内存实现是通过 CAS 实现的!
    AtomicLong, AtomicInteger, AtomicDouble ...

LongAdder 源码解析
    (1) LongAdder 的结构是怎么样的?
        volatile long base;         base 基数值
        volatile Cell[] cells;      多线程竞争时 Cell
        volatile int cellsBusy;     单个的自旋锁 用来初始化 或 调整表大小

    (2) 当前线程应该访问 Cell 数组里面的 哪一个 Cell 元素?
        通过add(long x) 来看 (2)(3)(4) 条件就是判断获取的哪个 Cell 元素!
        public void add(long x) {
            Cell[] as; long b, v; int m; Cell a;
            if ((as = cells) != null || !casBase(b = base, b + x)) {    // (1)
                boolean uncontended = true;
                if (as == null || (m = as.length - 1) < 0 ||            // (2)
                    (a = as[getProbe() & m]) == null ||                 // (3)
                    !(uncontended = a.cas(v = a.value, v + x)))         // (4)
                    longAccumulate(x, null, uncontended);               // (5)
            }
        }

    (3) 如果初始化 Cell 数组?
        使用单个自旋锁 volatile int cellsBusy; 来初始化 Cell 数组

    (4) Cell 数组如何扩容?
        使用当个自旋锁 volatile int cellsBusy; 来调整 Cell[] 数组的 大小!

    (5) 线程访问分配的 Cell 元素有冲突后 如何处理?
        进行2倍的扩充, 然后进行元素复制, 代码如下:
        if (cellsBusy == 0 && casCellsBusy()) {
            try {
                if (cells == as) {      // Expand table unless stale
                    Cell[] rs = new Cell[n << 1];   // TODO Cell[] 长度进行2倍扩充, 然后进行 元素copy
                    for (int i = 0; i < n; ++i)
                        rs[i] = as[i];
                    cells = rs;
                }
            } finally {
                cellsBusy = 0;
            }
            collide = false;
            continue;                   // Retry with expanded table
        }

    (6) 如何保证线程操作被分配的 Cell 元素的原子性?
        修改 Cell 元素里面的值, 是使用 CAS 操作完成的

------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------- 第5章 Java并发包中 并发List 的原理剖析 --------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------
CopyOnWriteArrayList 源码解析 请看 CopyOnWriteArrayList

线程安全的类再理解: 所谓线程安全 是指 没有超出我们的预期, 没有说 不抛出异常, 例如 CopyOnWriteArrayListDemo.java 中描述的那样!

CopyOnWriteArraySet 和 CopyOnWriteArrayList 都是 增删改 的时候 进行快照复制(叫 写时复制), 然后修改快照, 然后将 array 指向修改后的快照快 进行处理的!

------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------ 第6章 Java并发包中 锁 的原理剖析 -----------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------
LockSupport 类 与 每个调用它的线程 都会关联一个许可证, 默认情况下 直接调用 LockSupport 的 线程不持有许可证!
    LockSupport.park() 方法执行:
        如果持有许可证, 则方法立即返回;
        如果不持有许可, 则调用线程阻塞, 默认情况下 直接调用 LockSupport.park() 的线程不持有许可, 这会造成当前线程直接阻塞!

    LockSupport.unpark() 方法执行:
        则是为当前线程获取到许可证!

    LockSupport.park() 和 LockSupport.unpark(Thread thread) 两个方法的使用, 请参考 LockSupportDemo0 ~ LockSupportDemo3 的例子!










