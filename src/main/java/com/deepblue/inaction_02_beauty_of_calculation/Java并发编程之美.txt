------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------- 第1章 并发编程线程基础 ----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------
进程: 是系统进行资源分配和调度的 单位正交基!
线程: 是CPU资源分配和调度的 单位正交基!

实现线程的三种方法:
    1、继承Thread
    2、实现Runnable
    3、实现Callable 进而实现 FutrueTask 来实现自己的线程

线程通知和等待 wait(), notify(), notifyAll()
    虚假唤醒:
    一个线程从 挂起状态 变成 可运行状态, 这个过程称为唤醒;  线程A可能就该轮到他执行了, 并没有经过 其他线程B 的 notify(), notifyAll() 方法 进行唤醒, 这种就是典型的 虚假唤醒!

    防止虚假唤醒的方式:
    锁住的执行代码块之内使用, 一直判定的 满足条件才 wait()

    使用规范如下:
    synchronized(obj) {
        while(不满足获取 obj 监视器的条件) {
            obj.wait();
        }
        ...
        obj.notify();
    }

    或

    synchronized(obj) {
        while(不满足获取 obj 监视器的条件) {
            obj.wait();
        }
        ...
        obj.notifyAll();
    }

    源码解析:
    /**
     * TODO 使当前线程进入等待状态
     * 使当前线程等待，直到另一个线程为此对象调用 {@link java.lang.Object#notify()} 方法或 {@link java.lang.Object#notifyAll()} 方法。
     * Causes the current thread to wait until another thread invokes the {@link java.lang.Object#notify()} method or the {@link java.lang.Object#notifyAll()} method for this object.
     *
     * 换句话说，这个方法的行为就像它只是执行调用 {@code wait(0)} 一样。
     * In other words, this method behaves exactly as if it simply performs the call {@code wait(0)}.
     * <p>
     * 当前线程必须拥有此对象的监视器。
     * The current thread must own this object's monitor.
     *
     * 线程释放此监视器的所有权并等待，直到另一个线程通知在此对象监视器上等待的线程通过调用 {@code notify} 方法或 {@code notifyAll} 方法唤醒。
     * The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object's monitor to wake up either through a call to the {@code notify} method or the {@code notifyAll} method.
     *
     * 然后线程等待直到它可以重新获得监视器的所有权并恢复执行。
     * The thread then waits until it can re-obtain ownership of the monitor and resumes execution.
     * <p>
     * 与单参数版本一样，中断和虚假唤醒是可能的，并且应始终在循环中使用此方法：
     * As in the one argument version, interrupts and spurious wakeups are possible, and this method should always be used in a loop:
     * <pre>
     *     synchronized (obj) {
     *         while (condition does not hold)  // 条件不成立
     *             obj.wait();
     *         ... // Perform action appropriate to condition   执行适合条件的动作
     *     }
     * </pre>
     * 此方法只能由作为此对象监视器所有者的线程调用。
     * This method should only be called by a thread that is the owner of this object's monitor.
     *
     * 有关线程可以成为监视器所有者的方式的描述，请参阅 {@code notify} 方法。
     * See the {@code notify} method for a description of the ways in which a thread can become the owner of a monitor.
     *
     * 如果当前线程不是对象监视器的所有者, 抛出 IllegalMonitorStateException
     * @throws  IllegalMonitorStateException  if the current thread is not the owner of the object's monitor.
     *
     *
     * @throws  InterruptedException
     *      如果任何线程在当前线程等待通知之前或期间中断了当前线程, 抛出 InterruptedException
     *      if any thread interrupted the current thread before or while the current thread was waiting for a notification.
     *      抛出 InterruptedException 异常时清除当前线程的中断状态。
     *      The interrupted status of the current thread is cleared when this exception is thrown.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#notifyAll()
     */
    public final void wait() throws InterruptedException {
        wait(0);
    }

    /**
     * 导致当前线程等待，直到另一个线程调用该对象的{@link java.lang.Object#notify()}方法或{@link java.lang.Object#notifyAll()}方法，或者已经经过了指定的时间。
     * Causes the current thread to wait until either another thread invokes the {@link java.lang.Object#notify()} method or the {@link java.lang.Object#notifyAll()} method for this object, or a specified amount of time has elapsed.
     * <p>
     * 当前线程必须拥有该对象的监视器。
     * The current thread must own this object's monitor.
     * <p>
     * 此方法使当前线程（称为 T）将自己置于此对象的等待集中，然后放弃对该对象的任何和所有同步声明。
     * This method causes the current thread (call it <var>T</var>) to place itself in the wait set for this object and then to relinquish any and all synchronization claims on this object.
     *
     * 线程 T 出于线程调度目的而被禁用并处于休眠状态，直到发生以下四种情况之一: TODO 含义: 以下四种情况发生, 都会导致当前线程处于非休眠状态
     * Thread <var>T</var> becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:
     * <ul>
     * 其他一些线程为此对象调用 {@code notify} 方法，并且线程 T 恰好被任意选择为要唤醒的线程。
     * <li>Some other thread invokes the {@code notify} method for this object and thread <var>T</var> happens to be arbitrarily chosen as the thread to be awakened.
     * 其他一些线程为此对象调用 {@code notifyAll} 方法。
     * <li>Some other thread invokes the {@code notifyAll} method for this object.
     * 其他一些线程 {@linkplain Thread#interrupt() 中断} 线程 T。
     * <li>Some other thread {@linkplain Thread#interrupt() interrupts} thread <var>T</var>.
     * 或多或少已经过了指定的实时时间。
     * <li>The specified amount of real time has elapsed, more or less.
     *
     * 但是，如果 {@code timeout} 为零，则不考虑实时时间，线程只是等待直到通知。
     * If {@code timeout} is zero, however, then real time is not taken into consideration and the thread simply waits until notified.
     * </ul>
     * 线程 T 然后从该对象的等待集中移除，并重新启用线程调度。
     * The thread <var>T</var> is then removed from the wait set for this object and re-enabled for thread scheduling.
     *
     * 然后它以通常的方式与其他线程竞争在对象上同步的权利；
     * It then competes in the usual manner with other threads for the right to synchronize on the object;
     *
     * 一旦它获得了对象的控制权，它对对象的所有同步声明都将恢复到之前的状态——也就是说，恢复到调用 {@code wait} 方法时的情况。
     * once it has gained control of the object, all its synchronization claims on the object are restored to the status quo ante - that is, to the situation as of the time that the {@code wait} method was invoked.
     *
     * 然后线程 T 从 {@code wait} 方法的调用中返回。
     * Thread <var>T</var> then returns from the invocation of the {@code wait} method.
     *
     * 因此，从 {@code wait} 方法返回时，对象和线程 {@code T} 的同步状态与调用 {@code wait} 方法时完全相同。
     * Thus, on return from the {@code wait} method, the synchronization state of the object and of thread {@code T} is exactly as it was when the {@code wait} method was invoked.
     * <p>
     * 线程也可以在没有被通知、中断或超时的情况下唤醒，即所谓的<i>虚假唤醒</i>。
     * A thread can also wake up without being notified, interrupted, or timing out, a so-called <i>spurious wakeup</i>.
     *
     * 虽然这在实践中很少发生，但应用程序必须通过测试应该导致线程被唤醒的条件来防止它，如果条件不满足则继续等待。
     * While this will rarely occur in practice, applications must guard against it by testing for the condition that should have caused the thread to be awakened, and continuing to wait if the condition is not satisfied.
     *
     * 换句话说，等待应该总是在循环中发生，就像这样：
     * In other words, waits should always occur in loops, like this one:
     * <pre>
     *     synchronized (obj) {
     *         while (condition does not hold)  // 条件不成立
     *             obj.wait(timeout);
     *         ... // Perform action appropriate to condition   执行适合条件的操作
     *     }
     * </pre>
     * 有关此主题的更多信息，请参阅 Doug Lea 的“Java 中的并发编程（第二版）”（Addison-Wesley，2000 年）中的第 3.2.3 节或 Joshua Bloch 的“Effective Java Programming Language Guide”（Addison-Wesley , 2001)。
     * (For more information on this topic, see Section 3.2.3 in Doug Lea's "Concurrent Programming in Java (Second Edition)" (Addison-Wesley, 2000), or Item 50 in Joshua Bloch's "Effective Java Programming Language Guide" (Addison-Wesley, 2001).
     *
     * <p>
     * 如果当前线程是{@linkplain java.lang.Thread#interrupt() interrupt}被任何线程在等待之前或期间中断，则抛出{@code InterruptedException}。
     * If the current thread is {@linkplain java.lang.Thread#interrupt() interrupted} by any thread before or while it is waiting, then an {@code InterruptedException} is thrown.
     * 在按照上述方法恢复该对象的锁状态之前，不会引发此异常。
     * This exception is not thrown until the lock status of this object has been restored as described above.
     *
     * <p>
     * 请注意，{@code wait} 方法将当前线程放入此对象的等待集中，因此仅解锁此对象；
     * Note that the {@code wait} method, as it places the current thread into the wait set for this object, unlocks only this object;
     * 当前线程可能同步的任何其他对象在线程等待时保持锁定。
     * any other objects on which the current thread may be synchronized remain locked while the thread waits.
     * <p>
     * 此方法只能由作为此对象监视器所有者的线程调用。
     * This method should only be called by a thread that is the owner of this object's monitor.
     * 有关线程可以成为监视器所有者的方式的描述，请参阅 {@code notify} 方法。
     * See the {@code notify} method for a description of the ways in which a thread can become the owner of a monitor.
     *
     * 等待的最长时间（以毫秒为单位）。
     * @param   timeout                       the maximum time to wait in milliseconds.
     * 如果超时值为负。
     * @throws  IllegalArgumentException      if the value of timeout is negative.
     * 如果当前线程不是对象监视器的所有者。
     * @throws  IllegalMonitorStateException  if the current thread is not the owner of the object's monitor.
     *
     * @throws  InterruptedException
     *      如果任何线程在当前线程等待通知之前或期间中断了当前线程。
     *      if any thread interrupted the current thread before or while the current thread was waiting for a notification.
     *      抛出此异常时清除当前线程的中断状态。
     *      The interrupted status of the current thread is cleared when this exception is thrown.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#notifyAll()
     */
    public final native void wait(long timeout) throws InterruptedException;

    /**
     * 等待这个线程死亡。
     * Waits for this thread to die.
     *
     * <p>
     * 此方法的调用行为与调用完全相同
     * An invocation of this method behaves in exactly the same way as the invocation
     *
     * <blockquote> {@linkplain #join(long) join}{@code (0)}
     * </blockquote>
     *
     * @throws  InterruptedException
     *      如果任何线程中断了当前线程。
     *      if any thread has interrupted the current thread.
     *      抛出 InterruptedException 异常时清除当前线程的中断状态。
     *      The interrupted status of the current thread is cleared when this exception is thrown.
     */
    public final void join() throws InterruptedException {
        join(0);
    }

    /**
     * 唤醒在此对象的监视器上等待的单个线程。
     * Wakes up a single thread that is waiting on this object's monitor.
     * 如果有多个线程正在等待该对象，则选择其中一个线程被唤醒。
     * If any threads are waiting on this object, one of them is chosen to be awakened.
     * 选择是任意的，并且由实现决定。
     * The choice is arbitrary and occurs at the discretion of the implementation.
     * 线程通过调用 {@code wait} 方法之一 等待获取对象的监视器。
     * A thread waits on an object's monitor by calling one of the {@code wait} methods.
     * <p>
     * 被唤醒的线程将无法直接执行，直到当前线程放弃对该对象的锁定。
     * The awakened thread will not be able to proceed until the current thread relinquishes the lock on this object.
     * 被唤醒的线程将以通常的方式与可能正在积极竞争以同步此对象的任何其他线程进行竞争；
     * The awakened thread will compete in the usual manner with any other threads that might be actively competing to synchronize on this object;
     * 例如，被唤醒的线程在成为下一个锁定该对象的线程时没有可靠的特权或劣势。
     * for example, the awakened thread enjoys no reliable privilege or disadvantage in being the next thread to lock this object.
     * <p>
     * 此方法只能由作为此对象监视器所有者的线程调用。
     * This method should only be called by a thread that is the owner of this object's monitor.
     * 线程通过以下三种方式之一成为对象监视器的所有者：
     * A thread becomes the owner of the object's monitor in one of three ways:
     * <ul>
     * 通过执行该对象的同步实例方法。
     * <li>By executing a synchronized instance method of that object.
     * 通过执行在对象上同步的 {@code synchronized} 语句的主体。
     * <li>By executing the body of a {@code synchronized} statement that synchronizes on the object.
     * 对于 {@code Class,} 类型的对象，通过执行该类的同步静态方法。
     * <li>For objects of type {@code Class,} by executing a synchronized static method of that class.
     * </ul>
     *
     * <p>
     * 一次只有一个线程可以拥有一个对象的监视器。
     * Only one thread at a time can own an object's monitor.
     *
     * 如果当前线程不是对象监视器的所有者。
     * @throws  IllegalMonitorStateException  if the current thread is not the owner of this object's monitor.
     * @see        java.lang.Object#notifyAll()
     * @see        java.lang.Object#wait()
     */
    public final native void notify();

    /**
     * 唤醒在此对象监视器上等待的所有线程。
     * Wakes up all threads that are waiting on this object's monitor.
     * 线程通过调用 {@code wait} 方法之一在对象的监视器上等待。
     * A thread waits on an object's monitor by calling one of the {@code wait} methods.
     * <p>
     * 被唤醒的线程将以通常的方式与可能正在积极竞争以同步此对象的任何其他线程进行竞争；
     * The awakened threads will not be able to proceed until the current thread relinquishes the lock on this object.
     * 例如，被唤醒的线程在成为下一个锁定该对象的线程时不享有可靠的特权或劣势。
     * The awakened threads will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened threads enjoy no reliable privilege or disadvantage in being the next thread to lock this object.
     * <p>
     * 此方法只能由作为此对象监视器所有者的线程调用。
     * This method should only be called by a thread that is the owner of this object's monitor.
     * 有关线程可以成为监视器所有者的方式的描述，请参阅 {@code notify} 方法。
     * See the {@code notify} method for a description of the ways in which a thread can become the owner of a monitor.
     *
     * 如果当前线程不是对象监视器的所有者。
     * @throws  IllegalMonitorStateException  if the current thread is not the owner of this object's monitor.
     * @see        java.lang.Object#notify()
     * @see        java.lang.Object#wait()
     */
    public final native void notifyAll();

    TODO wait(), wait(long timeout), notify(), notifyAll() 这些方法 必须满足 当前线程是对象监视器的所有者

    notify()    表示 唤醒 当前线程所持有 对象监听器的 阻塞队列中的 一个线程!
    notifyAll() 表示 唤醒 当前线程所持有 对象监听器的 阻塞队列中的 所有线程!

等待线程执行中止的方法 join()
    thread.join() 上面的源码中 表示 等待当前线程死亡!
    现实生活中这个用的比较多, 例如 线程A 加载 数据A + 线程B 加载 数据B --> 计算 数据A 和 数据B --> 得出结果! 这就需要 线程A 和 线程B 都必须 完成 才能继续 接下来的 任务, 这时就需要 用到 Thread.join() 方法了

让线程睡眠的方法 sleep()

    /**
     * 使当前正在执行的线程休眠（暂时停止执行）指定的毫秒数，取决于系统计时器和调度程序的精度和准确性。
     * Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds, subject to the precision and accuracy of system timers and schedulers.
     *
     * 该线程不会失去任何监视器的所有权。TODO 释放cpu资源, 不释放锁!
     * The thread does not lose ownership of any monitors.
     *
     * @param  millis
     *         以毫秒为单位的睡眠时间长度
     *         the length of time to sleep in milliseconds
     *
     * @throws  IllegalArgumentException
     *          如果 {@code millis} 的值为负
     *          if the value of {@code millis} is negative
     *
     * @throws  InterruptedException
     *          如果任何线程中断了当前线程。
     *          if any thread has interrupted the current thread.
     *          抛出此异常时清除当前线程的中断状态。
     *          The interrupted status of the current thread is cleared when this exception is thrown.
     */
    public static native void sleep(long millis) throws InterruptedException;

让CPU让出执行权的方法 yield()

    源码解析:
    /**
     * 向调度程序提示当前线程愿意让出 ts 当前使用的处理器。
     * A hint to the scheduler that the current thread is willing to yield ts current use of a processor.
     * 调度程序可以随意忽略此提示。
     * The scheduler is free to ignore this hint.
     *
     * <p>
     * Yield 是一种启发式尝试，旨在改善线程之间的相对进展，否则会过度使用 CPU。
     * Yield is a heuristic attempt to improve relative progression between threads that would otherwise over-utilise a CPU.
     * 它的使用应与详细的分析和基准测试相结合，以确保它确实具有预期的效果。
     * Its use should be combined with detailed profiling and benchmarking to ensure that it actually has the desired effect.
     *
     * <p>
     * 很少适合使用这种方法。
     * It is rarely appropriate to use this method.
     * 它对于调试或测试目的可能很有用，它可能有助于重现由于竞争条件引起的错误。
     * It may be useful for debugging or testing purposes, where it may help to reproduce bugs due to race conditions.
     * 在设计并发控制结构（例如 {@link java.util.concurrent.locks} 包中的结构）时，它也可能很有用。
     * It may also be useful when designing concurrency control constructs such as the ones in the {@link java.util.concurrent.locks} package.
     */
    public static native void yield();

线程中断
    线程中断是线程之间的一种写作模式, 线程中断是根据当前线程中断标识来进行自行处理的, 这种处理极有可能不是立即执行的!
    源码解析: interrupt();
    /**
     * 中断此线程
     * Interrupts this thread.
     *
     * <p>
     * 除非当前线程自己中断，这总是被允许的，否则会调用此线程的 {@link #checkAccess() checkAccess} 方法，这可能会导致抛出 {@link SecurityException}。
     * Unless the current thread is interrupting itself, which is always permitted, the {@link #checkAccess() checkAccess} method of this thread is invoked, which may cause a {@link SecurityException} to be thrown.
     *
     * <p>
     * 如果此线程在调用中被阻塞
     * If this thread is blocked in an invocation
     * 调用了Object类的 wait(), wait(long), wait(long, int)
     * of the {@link Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link Object#wait(long, int) wait(long, int)} methods of the {@link Object} class,
     * 调用了Thread类的 join(), join(long), sleep(long), sleep(long, int)
     * or of the {@link #join()}, {@link #join(long)}, {@link #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)}, methods of this class,
     * 那么它的中断状态将被清除，并且它会收到一个 {@link InterruptedException}。
     * then its interrupt status will be cleared and it will receive an {@link InterruptedException}.
     *
     * <p>
     * 如果此线程在 {@link java.nio.channels.InterruptibleChannel InterruptibleChannel} 上的 I/O 操作中被阻塞，则通道将关闭，线程的中断状态将被设置，线程将收到一个 {@link java .nio.channels.ClosedByInterruptException}。
     * If this thread is blocked in an I/O operation upon an {@link java.nio.channels.InterruptibleChannel InterruptibleChannel} then the channel will be closed, the thread's interrupt status will be set, and the thread will receive a {@link java.nio.channels.ClosedByInterruptException}.
     *
     * <p> TODO java.nio.channels.Selector 需要看 netty
     * 如果此线程在 {@link java.nio.channels.Selector} 中被阻塞，则该线程的中断状态将被设置，并且它将立即从选择操作中返回，可能具有非零值，就像选择器的 { @link java.nio.channels.Selector#wakeup wakeup} 方法被调用。
     * If this thread is blocked in a {@link java.nio.channels.Selector} then the thread's interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector's {@link java.nio.channels.Selector#wakeup wakeup} method were invoked.
     *
     * <p>
     * 如果前面的条件都不成立，则将设置此线程的中断状态。
     * If none of the previous conditions hold then this thread's interrupt status will be set.
     *
     * <p>
     * 中断一个不活跃的线程不需要有任何影响。
     * Interrupting a thread that is not alive need not have any effect.
     *
     * @throws  SecurityException
     *          if the current thread cannot modify this thread     // 如果当前线程不能修改这个线程
     *
     * @revised 6.0
     * @spec JSR-51
     */
    public void interrupt() {
        if (this != Thread.currentThread())
            checkAccess();

        synchronized (blockerLock) {
            Interruptible b = blocker;
            if (b != null) {
                interrupt0();           // Just to set the interrupt flag   只是为了设置中断标志
                b.interrupt(this);
                return;
            }
        }
        interrupt0();
    }

    /**
     * 测试此线程是否已被中断。
     * Tests whether this thread has been interrupted.
     * 线程的中断状态不受此方法的影响。
     * The interrupted status of the thread is unaffected by this method.
     *
     * <p>
     * 由于线程在中断时不处于活动状态而被忽略的线程中断将通过此方法返回 false 来反映。 TODO 如果线程不处于活跃状态 则返回 false
     * A thread interruption ignored because a thread was not alive at the time of the interrupt will be reflected by this method returning false.
     *
     * @return  <code>true</code> if this thread has been interrupted;  // 当前线程处于中断状态   返回 true
     *          <code>false</code> otherwise.                           // 当前线程处于非中断状态 返回 false
     * @see     #interrupted()
     * @revised 6.0
     */
    public boolean isInterrupted() {
        return isInterrupted(false);
    }

    /**
     * 测试某个线程是否已被中断。
     * Tests if some Thread has been interrupted.
     * 中断状态是否根据传递的 ClearInterrupted 值重置。
     * The interrupted state is reset or not based on the value of ClearInterrupted that is passed.
     */
    private native boolean isInterrupted(boolean ClearInterrupted);

    Thread.interrupted() 方法 源码解析:
    /**
     * 测试当前线程是否被中断。
     * Tests whether the current thread has been interrupted.
     * 通过该方法清除线程的中断状态。
     * The interrupted status of the thread is cleared by this method.
     * 换句话说，如果这个方法被连续调用两次，第二次调用将返回 false（除非当前线程再次被中断，在第一次调用清除其中断状态之后，第二次调用检查它之前）。
     * In other words, if this method were to be called twice in succession, the second call would return false (unless the current thread were interrupted again, after the first call had cleared its interrupted status and before the second call had examined it).
     *
     * <p>
     * 由于线程在中断时不处于活动状态而被忽略的线程中断将通过此方法返回 false 来反映。 TODO 如果线程不处于活跃状态 则返回 false
     * A thread interruption ignored because a thread was not alive at the time of the interrupt will be reflected by this method returning false.
     *
     * @return  <code>true</code> if the current thread has been interrupted;   // 当前线程处于中断状态   返回 true
     *          <code>false</code> otherwise.                                   // 当前线程不处于中断状态 返回 false
     * @see #isInterrupted()
     * @revised 6.0
     */
    public static boolean interrupted() {
        return currentThread().isInterrupted(true);
    }

    线程优雅退出的代码如下: 这里的退出指的是退出正常工作
    if(!Thread.currentThread().isInterrupted() && do more work) {
        // do more work
    } else {
        // 中断 或 没有更多工作 要做 则 进入优雅退出 分支!
    }

