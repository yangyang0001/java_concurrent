************************************************************************************************************************************************************
******************************************************************** Java并发编程从入门到精通 ****************************************************************
************************************************************************************************************************************************************

------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------- 第1章 概念部分 --------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------
32位和64位概念: 每位的权重是字节, 所以32位表示 可以寻址的空间总大小为 2^32 byte
    寻址总空间大小为: 2^32 字节
    double bytes = Math.pow(2, 32);
    double k_bytes = bytes / 1024;
    double m_bytes = k_bytes / 1024;
    double g_bytes = m_bytes / 1024;
    System.out.println("bytes   = " + bytes  );
    System.out.println("k_bytes = " + k_bytes);
    System.out.println("m_bytes = " + m_bytes);
    System.out.println("g_bytes = " + g_bytes);

CPU核心数和线程数:
    核心数: 是指一个单体芯片内有多少个并行处理器
    线程数: 一般情况下核心数和线程数 = 1:1, 从Intel提出超线程技术后 核心数:线程数 = 1:2

时间片轮转机制: CPU 调度进程的算法

什么是进程, 什么是线程?
    进程的概念:
        进程是操作系统分配资源的最小单位, 操作系统分配的资源包括: CPU核数, 内存区域, 磁盘IO等;
    进程的特性:
        进程与进程之间是相互独立的, 进程分类: 用户进程和系统进程!
    系统进程: 所有用户支撑操作系统运行的进程统称为系统进程
    用户进程: 所有由用户启动的程序所属的进程统称为用户进程

    线程的概念:
        线程是CPU调度的最小单位, 必须依赖于进程存在, 不能单独运行!

    进程和线程的关系, 一个线程只归属于一个进程, 一个进程下可包含多个线程!

    Java中常见的线程: 日常中常见的main函数启动的程序都会对应一个线程!

并行和并发的概念和举例说明:
    并行: 从出发点A 到结束点B 之间有多少条高速公路, 这就叫并行能力
    并发: 从出发点A 到结束点B 之间单条高速公路上 单位时间内通过的车辆数量 叫并发能力


------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------- 第2章 Java中的Thread ----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------
线程的状态: 参考Thread.java类 中的6种状态 + Running状态 = 7种状态 NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED + RUNNING

实现线程的三种方式:
    1、继承Thread
    2、实现Runnable    最常用的实现线程的方式
    3、实现Callable

线程的优先级: 最小为1, 最大为10, 默认值为5

线程使用的注意事项:
    1、使用新的线程必须要为线程设置一个名称用于监控和查看
    2、主线程和子线程的生命周期极有可能不一致

线程的中断方法: 连续调用多次 interrupt() 方法, 中断标识位不是那么好判断! 总结: 如果中断标识位不发生改变线程无法中断

线程的状态:
    new         创建
    runnable    可执行
    running     执行中
    blocked     阻塞
    dead        消亡

线程常用方法:
    sleep()                 : 释放CPU, 不释放锁
    wait()                  : 释放CPU, 释放锁; 因此只有获取锁的线程才能调用wait()方法, 因此只能在 synchronized 代码块中使用
    notify()/notifyAll()    : 从等待池中唤醒(Waiting Pool), 同样只有获取相同的对象锁才能唤醒否则抛出异常
    yield()                 : 释放CPU, 暂时等待同优先级的线程执行, 如果没有同等优先级的线程, 则方法失效, 线程不等待

守护线程:
    概念: 如果一个线程不用关注它的消亡过程, 一般这种线程都是守护线程, 举例: Java虚拟机的垃圾回收, 内存管理都属于守护线程!
    使用: 在start() 之前调用 setDaemon(true) 方法就OK了
    验证: 守护线程不一定执行完成就有可能退出, 守护线程是不用关注退出的线程!
    注意: JRE判定程序是否执行完成的标准是 前台线程而非所有线程, 尤其不是根据守护进程是否结束来判定!

线程组:
    常见线程组: system线程组, main线程组

线程副本: ThreadLocal
    源码解析:
        ThreadLocal只是一个key, 这里面维护了线程的 ThreadLocalMap 属性, 因此每个线程的同类型的值在同一个ThreadLocal中只能存储一个值!
    使用注意:
        在使用完ThreadLocal后, 注意使用remove进行清除, 防止发生内存泄漏

线程异常的处理:
    CaughtExceptionHandler 接口的实现, 线程启动前注册: 调用setCaughtExceptionHandler(CaughtExceptionHandler handler)

------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------- 第3章 线程安全 ----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------
CPU处理数据的所经过的部件
























































































------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------- 第II部分 构建并发程序 --------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------




------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------- 第III部分 活跃度性、性能测试 ---------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------





------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------- 第IV部分 高级主题 ------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------