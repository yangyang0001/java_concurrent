************************************************************************************************************************************************************
******************************************************************** Java并发编程从入门到精通 ****************************************************************
************************************************************************************************************************************************************

------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------- 第1章 概念部分 --------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------
32位和64位概念: 每位的权重是字节, 所以32位表示 可以寻址的空间总大小为 2^32 byte
    寻址总空间大小为: 2^32 字节
    double bytes = Math.pow(2, 32);
    double k_bytes = bytes / 1024;
    double m_bytes = k_bytes / 1024;
    double g_bytes = m_bytes / 1024;
    System.out.println("bytes   = " + bytes  );
    System.out.println("k_bytes = " + k_bytes);
    System.out.println("m_bytes = " + m_bytes);
    System.out.println("g_bytes = " + g_bytes);

CPU核心数和线程数:
    核心数: 是指一个单体芯片内有多少个并行处理器
    线程数: 一般情况下核心数和线程数 = 1:1, 从Intel提出超线程技术后 核心数:线程数 = 1:2

时间片轮转机制: CPU 调度进程的算法

什么是进程, 什么是线程?
    进程的概念:
        进程是操作系统分配资源的最小单位, 操作系统分配的资源包括: CPU核数, 内存区域, 磁盘IO等;
    进程的特性:
        进程与进程之间是相互独立的, 进程分类: 用户进程和系统进程!
    系统进程: 所有用户支撑操作系统运行的进程统称为系统进程
    用户进程: 所有由用户启动的程序所属的进程统称为用户进程

    线程的概念:
        线程是CPU调度的最小单位, 必须依赖于进程存在, 不能单独运行!

    进程和线程的关系, 一个线程只归属于一个进程, 一个进程下可包含多个线程!

    Java中常见的线程: 日常中常见的main函数启动的程序都会对应一个线程!

并行和并发的概念和举例说明:
    并行: 从出发点A 到结束点B 之间有多少条高速公路, 这就叫并行能力
    并发: 从出发点A 到结束点B 之间单条高速公路上 单位时间内通过的车辆数量 叫并发能力


------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------- 第2章 Java中的Thread ----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------
线程的状态: 参考Thread.java类 中的6种状态 + Running状态 = 7种状态 NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED + RUNNING

实现线程的三种方式:
    1、继承Thread
    2、实现Runnable    最常用的实现线程的方式
    3、实现Callable

线程的优先级: 最小为1, 最大为10, 默认值为5

线程使用的注意事项:
    1、使用新的线程必须要为线程设置一个名称用于监控和查看
    2、主线程和子线程的生命周期极有可能不一致

线程的中断方法: 连续调用多次 interrupt() 方法, 中断标识位不是那么好判断! 总结: 如果中断标识位不发生改变线程无法中断

线程的状态:
    new         创建
    runnable    可执行
    running     执行中
    blocked     阻塞
    dead        消亡

线程常用方法:
    sleep()                 : 释放CPU, 不释放锁
    wait()                  : 释放CPU, 释放锁; 因此只有获取锁的线程才能调用wait()方法, 因此只能在 synchronized 代码块中使用
    notify()/notifyAll()    : 从等待池中唤醒(Waiting Pool), 同样只有获取相同的对象锁才能唤醒否则抛出异常
    yield()                 : 释放CPU, 暂时等待同优先级的线程执行, 如果没有同等优先级的线程, 则方法失效, 线程不等待

守护线程:
    概念: 如果一个线程不用关注它的消亡过程, 一般这种线程都是守护线程, 举例: Java虚拟机的垃圾回收, 内存管理都属于守护线程!
    使用: 在start() 之前调用 setDaemon(true) 方法就OK了
    验证: 守护线程不一定执行完成就有可能退出, 守护线程是不用关注退出的线程!
    注意: JRE判定程序是否执行完成的标准是 前台线程而非所有线程, 尤其不是根据守护进程是否结束来判定!

线程组:
    常见线程组: system线程组, main线程组

线程副本: ThreadLocal
    源码解析:
        ThreadLocal只是一个key, 这里面维护了线程的 ThreadLocalMap 属性, 因此每个线程的同类型的值在同一个ThreadLocal中只能存储一个值!
    使用注意:
        在使用完ThreadLocal后, 注意使用remove进行清除, 防止发生内存泄漏

线程异常的处理:
    CaughtExceptionHandler 接口的实现, 线程启动前注册: 调用setCaughtExceptionHandler(CaughtExceptionHandler handler)

------------------------------------------------------------------------------------------------------------------------------------------------------------
----------------------------------------------------------------------- 第3章 线程安全 ----------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------
CPU处理数据的所经过的部件
    读取过程: 内存 ---> 高速缓存 ---> 寄存器 ---> CPU
    写回过程: CPU ---> 寄存器 ---> 高速缓存 ---> 内存

线程与线程之间不能直接交互数据, 只能通过共享变量的方式进行数据交互

什么是线程不安全:
    前提: 线程A 和 线程B 都能修改 堆中 共享变量C
        1、线程A 修改堆中 共享变量C 的过程对于线程B来说是不可见的, 这种术语叫 可见性
        2、线程A 修改 共享变量C 的过程可能会出现如下情况
            read-load       线程A 的工作内存中 没有 共享变量C的 副本, 则执行 read-load 指令
            read-load-use   线程A 的工作内存中 如果 存在共享变量C的副本, 可能 会重新拉取 堆中 共享变量C 然后再使用
            use             线程A 的工作内存中 如果 存在共享变量C的副本, 可能 会直接使用 工作内存中的副本
           这种问题会造成, 线程A修改 共享变量C 时, 线程B可能已经回写 共享变量值, 造成共享变量 的覆盖而 导致错误
           这种问题术语 时序性

    不安全概念: 由于可见性和时序性 导致共享变量的值 和 预期的值不一致的 效果 叫线程不安全

什么是线程安全:
    无论有多少个线程 对 同一个堆中的 共享变量 执行事务性操作, 产生的结果和我们预期的结果一致, 这就叫 线程安全性

线程安全的实现方式:
    1、不使用单例的共享变量
    2、使用java.util.concurrent.*
    3、使用锁机制 synchronized, lock 机制

隐式锁: synchronized
    主要特点: 同一 object 的 synchronized(this) 修饰的代码块, 排斥其他任何线程, 这种规则同样适用于 其他 对象锁

    隐式锁的执行效率优先级:
    方法块 < 代码块 < 小对象的
    常用方式如下:
    private byte[] lock = new byte[1];
    public void methodA() {
        synchronized(lock) {
            ...
        }
    }

显示锁: Lock 和 ReentrantLock

显示锁: ReadWriteLock 和 ReentrantReadWriteLock
    公平性: 默认的 非公平锁; 公平锁: 使用AQS的CLH 队列实现
    重入性:
    重入数: 最大是65535
    锁降级: 从 写锁 降级为 读锁, 自动完成
    锁升级: 从 读锁 升级为 写锁, 不能自动完成, 因为升级写锁之前 要 释放掉所有的 读锁
    条件变量: 只有写锁有条件, 读锁没有公平和非公平性
    使用场景: 读取线程多, 写入线程少 的时候!
    总结:
        读-读: 不互斥
        读-写: 互斥
        写-写: 互斥


悲观锁: 假定会发生并发问题, 会破坏数据的完整性; 在读取之前就验证一下数据是否正在被修改!
乐观锁: 假定不会发生并发问题, 只是在提交修改的时候检查是否违反了数据完整性!

什么是死锁: 当线程A 和 线程B 都在等待对方释放锁才能继续工作时, 而产生共同阻塞的情况 称为 死锁!

volatile: 指的是线程每次读取变量 都是从 栈内存中读取, 但不能保证 每次都写回栈内存中, 因此可以做到 栈内存的可见性, 但是不能保证原子性, 所以高并发的情况下是线程不安全的!

volatile 和 锁 的区别: 前者只能保证内存可见性, 但是不能保证原子性! 后者即能保证可见性, 也能保证原型性!





















































































------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------- 第II部分 构建并发程序 --------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------




------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------- 第III部分 活跃度性、性能测试 ---------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------





------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------- 第IV部分 高级主题 ------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------